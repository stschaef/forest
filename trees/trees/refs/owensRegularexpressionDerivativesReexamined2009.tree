% ["references"]
\title{Regular-expression derivatives re-examined}
\date{2009-03}
\author/literal{Scott Owens}\author/literal{John Reppy}\author/literal{Aaron Turon}
\taxon{reference}
\meta{doi}{10.1017/S0956796808007090}
\meta{external}{https://www.cambridge.org/core/product/identifier/S0956796808007090/type/journal_article}
\tag{parsing}

\meta{bibtex}{\startverb
@article{owensRegularexpressionDerivativesReexamined2009,
 title = {Regular-expression derivatives re-examined},
 author = {Owens, Scott and Reppy, John and Turon, Aaron},
 year = {2009},
 doi = {10.1017/S0956796808007090},
 url = {https://www.cambridge.org/core/product/identifier/S0956796808007090/type/journal_article},
 urldate = {2024-04-29},
 journal = {Journal of Functional Programming},
 volume = {19},
 number = {2},
 pages = {173--190},
 file = {Owens et al. - 2009 - Regular-expression derivatives re-examined.pdf:/Users/stevenschaefer/Zotero/storage/PQB9TTVL/Owens et al. - 2009 - Regular-expression derivatives re-examined.pdf:application/pdf},
 month = {March},
 language = {en},
 abstract = {Abstract
Regular-expression derivatives are an old, but elegant, technique for compiling regular expressions to deterministic finite-state machines. It easily supports extending the regular-expression operators with boolean operations, such as intersection and complement. Unfortunately, this technique has been lost in the sands of time and few computer scientists are aware of it. In this paper, we reexamine regular-expression derivatives and report on our experiences in the context of two different functional-language implementations. The basic implementation is simple and we show how to extend it to handle large character sets (e.g., Unicode). We also show that the derivatives approach leads to smaller state machines than the traditional algorithm given by McNaughton and Yamada.},
 issn = {0956-7968, 1469-7653},
 copyright = {https://www.cambridge.org/core/terms}
}
\stopverb}
