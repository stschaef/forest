[{"DOI": "10.1145/2837614.2837640", "ISBN": "9781450335492", "URL": "https://doi.org/10.1145/2837614.2837640", "abstract": "Induction is a successful approach for verification of hardware and software systems. A common practice is to model a system using logical formulas, and then use a decision procedure to verify that some logical formula is an inductive safety invariant for the system. A key ingredient in this approach is coming up with the inductive invariant, which is known as invariant inference. This is a major difficulty, and it is often left for humans or addressed by sound but incomplete abstract interpretation. This paper is motivated by the problem of inductive invariants in shape analysis and in distributed protocols. This paper approaches the general problem of inferring first-order inductive invariants by restricting the language L of candidate invariants. Notice that the problem of invariant inference in a restricted language L differs from the safety problem, since a system may be safe and still not have any inductive invariant in L that proves safety. Clearly, if L is finite (and if testing an inductive invariant is decidable), then inferring invariants in L is decidable. This paper presents some interesting cases when inferring inductive invariants in L is decidable even when L is an infinite language of universal formulas. Decidability is obtained by restricting L and defining a suitable well-quasi-order on the state space. We also present some undecidability results that show that our restrictions are necessary. We further present a framework for systematically constructing infinite languages while keeping the invariant inference problem decidable. We illustrate our approach by showing the decidability of inferring invariants for programs manipulating linked-lists, and for distributed protocols.", "author": [{"family": "Padon", "given": "Oded"}, {"family": "Immerman", "given": "Neil"}, {"family": "Shoham", "given": "Sharon"}, {"family": "Karbyshev", "given": "Aleksandr"}, {"family": "Sagiv", "given": "Mooly"}], "collection-title": "POPL \u201916", "container-title": "Proceedings of the 43rd annual ACM SIGPLAN-SIGACT symposium on principles of programming languages", "id": "padonDecidabilityInferringInductive2016", "issued": {"date-parts": [[2016]]}, "keyword": "well-quasi-order, verification, invariant inference, effectively propositional logic", "page": "217-231", "publisher": "Association for Computing Machinery", "publisher-place": "New York, NY, USA", "title": "Decidability of inferring inductive invariants", "type": "paper-conference", "original_bibtex": "@inproceedings{padonDecidabilityInferringInductive2016,\n title = {Decidability of inferring inductive invariants},\n author = {Padon, Oded and Immerman, Neil and Shoham, Sharon and Karbyshev, Aleksandr and Sagiv, Mooly},\n year = {2016},\n isbn = {9781450335492},\n doi = {10.1145/2837614.2837640},\n url = {https://doi.org/10.1145/2837614.2837640},\n booktitle = {Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},\n series = {POPL '16},\n pages = {217\u2013231},\n publisher = {Association for Computing Machinery},\n address = {New York, NY, USA},\n location = {St. Petersburg, FL, USA},\n keywords = {well-quasi-order, verification, invariant inference, effectively propositional logic},\n numpages = {15},\n abstract = {Induction is a successful approach for verification of hardware and software systems. A common practice is to model a system using logical formulas, and then use a decision procedure to verify that some logical formula is an inductive safety invariant for the system. A key ingredient in this approach is coming up with the inductive invariant, which is known as invariant inference. This is a major difficulty, and it is often left for humans or addressed by sound but incomplete abstract interpretation. This paper is motivated by the problem of inductive invariants in shape analysis and in distributed protocols. This paper approaches the general problem of inferring first-order inductive invariants by restricting the language L of candidate invariants. Notice that the problem of invariant inference in a restricted language L differs from the safety problem, since a system may be safe and still not have any inductive invariant in L that proves safety. Clearly, if L is finite (and if testing an inductive invariant is decidable), then inferring invariants in L is decidable. This paper presents some interesting cases when inferring inductive invariants in L is decidable even when L is an infinite language of universal formulas. Decidability is obtained by restricting L and defining a suitable well-quasi-order on the state space. We also present some undecidability results that show that our restrictions are necessary. We further present a framework for systematically constructing infinite languages while keeping the invariant inference problem decidable. We illustrate our approach by showing the decidability of inferring invariants for programs manipulating linked-lists, and for distributed protocols.}\n}\n"}]